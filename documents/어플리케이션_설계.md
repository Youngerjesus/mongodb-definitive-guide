# 어플리케이션 설계 

여기서는 어플리케이션에서 몽고 DB 를 효율적으로 작동하도록 설계하는 방법을 다룬다. 

- 스키마 설계 고려사항

- 데이터 내장 (embed) 방식과 참조 방식 중 결정하기 

- 최적화를 위한 팁 

- 일관성 고려 사항 

- 스키마 마이그레이션 방법 

- 스키마 관리 방법 

- 몽고 DB 가 데이터 스토로지로 적합하지 않은 경우 

## 스키마 설계 고려사항
 
스키마 설계를 관계형 데이터베이스와 똑같이 생각하면 안됨. 

- 관계형 데이터베이스는 주로 어플리케이션에 필요한 데이터를 생각해서 디자인 하는데 여기서는 그것외에 더 많은 고려가 필요하다.

스키마 설계할 때 고려할 사항은 다음과 같다.  

- 도큐먼트의 크기와 원자성 

  - 도큐먼트의 최대 크기는 16MB 이고 도큐먼트 단위로 갱신된다.
  - 원자성도 도큐먼트 단위이다.

- 쿼리 및 쓰기의 접근 패턴 

  - 어떻게 쿼리가 올 지 예측하고 쿼리 수를 최소화하고, 함께 쿼리되는 데이터가 동일한 도큐먼트에 저장되도록 설계해야한다. 
  - 도큐먼트를 쪼개지 말고 쿼리를 예측하고 쿼리를 도큐먼트에 포함시키라는 뜻 같다.

- 도큐먼트간 관계 유형

  - 도큐먼트 관계를 고려해야한다. 내부 도큐먼트로 넣을지, 어떻게 참조할 지를 고려해야한다. (추가 쿼리 없이 가능하면.) 
  - 갱신될 때 어떻게 갱신되는지도 고려해야함.
  - (참조는 조인을 말하는듯.)

- 카디널리티 

  - 도큐먼트의 관계가 정해졌다면 관계의 카디널리티도 고려해야한다. 
  - 관계의 카디널리티는 일대일인지, 일대다인지, 다대다인지, 일대수백만인지, 다대수십억인지 등을 고려하는 것. 
  - 몽고 DB 스키마에서 관계의 카디널리티를 설정하는 것이 중요하다. 
    - 수백만 개체가 개별적으로 접근되는지, 상위 개체의 컨택스트 내에서만 접근되는지, 읽기 갱신 비율은 어떻게 되는지를 고려하면 도큐먼트의 정규화 유무와 참조할지, 내장할지가 결정된다. 

## 스키마 설계 패턴 

적용할 수 있는 스키마 설계 패턴을 하나씩 보자.

### 다형성 패턴 (polymorphic pattern)

다형성 패턴은 컬렉션 내 모든 도큐먼트가 유사하지만 동일하지 않은 구조일 때 적합하다. 

이 패턴을 사용할 땐 공통 쿼리를 지원하는 공통 필드를 먼저 식별하는 것이 포함된다. 

그리고 도큐먼트나 서브 도큐먼트의 특정 필드를 추적해서 차이점을 알고 이를 통해서 어플리케이션에서 코딩하면 된다. 

### 속성 패턴 (attribute pattern)

속성 패턴은 정렬하거나 쿼리하려는 도큐먼트의 필드에 서브셋이 있는 경우나 필드가 도큐먼트의 서브셋에 존재하는 경우에 사용한다. 

이 경우에는 데이터를 키/값 쌍의 배열로 재구성하고 배열 요소에 인덱스를 만들면 된다.

### 버킷 패턴 (bucket pattern)

버킷 패턴은 데이터가 일정 기간 동안 스트림으로 유입되는 시계열 데이터에 적합하다. 

몽고 DB 에서 이런 데이터를 특정 시간 버위의 데이터를 보유하는 도큐먼트 셋으로 버킷화하면 훨씬 편리하다. 

예를 들어 1시간 버킷을 사용하면 해당 시간동안 모든 값을 하나의 도큐먼트 배열에 배치하는게 가능하다. 

그리고 도큐먼트 자체에는 이 버킷이 다루는 기간을 나타내는 시작과 종료 시간이 포함된다. 

### 이사치 패턴 (outlier pattern)

이상치 패턴은 도큐먼트의 쿼리가 어플리케이션의 정상적인 범위에 벗어난 경우를 표시하기 위해서 사용한다. 

예를 들면 인기도 (popularity) 가 중요한 상황을 위한 설계된 패턴으로 도서 판매, 주요 영향 요인등에 사용한다. 

플래그 (Flag) 를 통해서 도큐먼트가 이상치임을 나타낸다 

### 계산된 패턴 (computed pattern)

계산된 패턴은 데이터를 자주 계싼해야 할 때나 데이터 접근 패턴이 읽기 집약일 때 사용한다. 

계싼은 주기적으로 백그라운드에서 계산되도록 하고, 동일한 계산에 CPU 를 너무 많이 쓰지 않도록 주기를 두도록 한다. 


### 서브셋 패턴 (subset pattern)

서브셋 패턴은 장비의 램 용량을 초과하는 작업이 있을 때 사용한다. 

예를 들어서 어플리케이션에서 대용량의 데이터를 가지고 올 수 있는 경우에 발생하는 문제 떄문인데 매번 가지고 오는 경우가 아니라 드물게 가지고 오는 경우에 사용한다. 

서브셋 패턴은 자주 사용하는데 자주 사용하는 데이터와 자주 사용하지 않는 데이터를 두 개의 개별적인 컬렉션으로 분리해서 사용한다. 

- **(난 처음에 같은 컬렉션에 두고 인덱스로 구별하면 되지 않을까? 했는데 인덱스로 구별하는 것보다 풀스캔으로 가지고 오고 싶은 경우에 쓰지 않을까 싶다. 인덱스의 효율성이 그렇게 나오지 않는 경우라면 이렇게 쓰는 것인가.)**

일반적인 예로 전자 상거래 어플리케이션인데 최근 리뷰 몇 개와 모든 리뷰를 구별해서 컬렉션을 가져가는 경우에 쓸 수 있겠다. 


### 확장된 참조 패턴 (extended reference pattern)

확장된 참조 패턴은 하나의 컬렉션에 모든 정보를 다 넣어서 사이즈가 커지고, 성능이 느려지고, 데이터 중복이 생기는 문제를 피하고 이를 참조로 해결하자는 패턴이다. 

- 예를 들어 전자 상거래 어플리케이션에서 주문, 재고, 고객이 있다면 주문에 모든 데이터를 다 넣는게 아니라 주문과 고객 제고 를 분리하는 걸 말한다. 

### 근사 패턴 (approximation pattern)

근사 패턴은 리소스는 많이 들지만 (CPU, Memory, 시간 등) 결과는 비교적 정확하지 않아도 되는 경우에 사용할 수 있다. 

주로 이미지나 게시글의 추천 수가 이와 같은 상황인데 근사 패턴을 통해서 매번 갱신하는게 아니라 100회가 될 때마다 갱긴하도록 할 수 있다.

- **데이터베이스에 가능한 쓰기를 덜 하도록 하는게 핵심**


### 트리 패턴 (tree pattern)

트리 패턴은 구조적으로 계층적인 데이터가 있을 때 사용한다. 

일반적으로 함께 쿼리되는 데이터를 모아서 저장을 하고 몽고 DB 기준으로는 배열에 계층 구조를 넣어서 저장한다. 

예를 보면 전자 상거래의 제품 카탈로그를 보면 되는데 여러 범주에 속하거나 다른 제품의 하위 범주에 속하는 제품의 경우에 사용할 수 있다. 

하드 디스크의 경우 그 자체가 범주이지만 '기억장치' 범주에 속하고 '전자제품' 범주에 속한다. 

이 경우 즉각적임 범주 (= 하드 디스크) 와 전쳬 계층구조를 추적하는 필드가 있을 것이다. 

전체 계층구조를 추적하는 필드를 배열에 넣고 다중키 인덱스를 걸어놓는다.

### 사전 할당 패턴 (preallocation pattern)

사전 할당 패턴은 주로 MMAP 스토로지 엔진과 함께 사용했지만 여전히 사용되는 패턴이다. 

이 패턴은 빈 구조를 먼저 사전할당하고 이걸 이후에 채워넣는 방식이다. 

예를 들면 예약 정보를 관리하는 시스템에서 예약 가능 여부와 현재 예약 상태를 추적하는데 사용한다.


### 도큐먼트 버전 관리 패턴 (document versioning pattern) 

도큐먼트 버전 관리 패턴은 도큐먼트의 이전 버전을 유지하는 매커니즘을 제공한다. 

이 패턴을 쓰기 위해선 도큐먼트 버전을 추적하기 위해서 부가 필드가 필요하고 도큐먼트의 모든 수정 사항을 포함하는 추가 컬렉션이 필요하다. 

패턴을 쓸 땐 몇가지 고려사항이 있다.

- 각 도큐먼트의 수정 사항 너무 많으면 안되고

- 도큐먼트의 버전이 너무 많으면 또 안된다. 

- 대부분의 쿼리는 현재의 도큐먼트를 위주로 작성된다. 

## 정규화 vs 비정규화 

데이터를 표현하는 방법은 다양하며 데이터를 얼마만큼 정규화를 할 지는 중요한 문제다.

정규화는 컬렉션간의 참조를 이용해서 데이터를 여러 컬렉션으로 쪼개는 작업이다.

몽고 DB 는 left outer join 을 지원하는 `$lookup` 연산을 지원한다.

비정규화는 하나의 도큐먼트에 모든 데이터를 넣는 방식이다.

정규화는 쓰기를 빠르게 하지만 비정규화는 읽기를 빠르게 한다는 장점이 있다.
 
### 정규화 예제 

학생과 학생이 수강중인 과목에 대한 정보를 저장한다고 가정해보자. 

- 학생은 students 컬렉션에 들어갈 것이고, 과목은 classes 컬렉션에 들어갈 것이다.

이를 표현하는 방법은 여러개가 있을 것. 

- 관계형 DB 처럼 표현하기: Students 컬렉션, Classes 컬렉션, StudentClasses 컬렉션 (조인 관계를 위해 1:N 관계 표시)
  - 세번의 쿼리를 날려야 한다는 단점이 있음.
- 역참조 (dereference) 이용하기: Students 컬렉션 도큐먼트에 Classes 컬렉션 도큐먼트를 참조할 수 있는 _id 값을 넣어두는 
  - 두 번의 쿼리를 날리면 됨. 일반적인 경우
- 비정규화 방법: Classes 컬렉션을 없애고 Students 컬렉션 도큐먼트 내부에 넣는 것
  - 한 번의 쿼리로 가능. 
  - 다만 Class 정보를 바꾸려면 모든 Student 를 전수조사 해봐야함.
- Extended Reference 방법: 자주 사용하는 과목 정보는 Students 컬렉션에 넣어두고, 더 필요하다면 Classes 컬렉션 참조를 해보는 것.

이 예시로 중요한 건 결국에 **데이터의 변경 가능성을 따져보는 것이다.**

- 정규화를 할 수록 읽기 비용이 커지고 쓰기 비용이 작아진다. 갱신되지 않을 녀석 때문에 정규화를 해서 읽기 비용을 낮출 필요는 없다.

- 예를 들어서 교과서적인 정규화 사용은 주소와 인물의 정보를 각각 별도의 컬렉션에 넣는 것이지만 주소가 변경될 여지는 적으므로 인물 컬렉션에 넣어도 된다. 읽기 비용을 해치지 않기 위해서

그리고 갱신 연산자를 주의하자. 

- `$set` 은 멱등성 연산자이지만 `$inc` 는 그렇지 않다.

- **그래서 이 경우에는 멱등성 연산자로 바꿔주는 작업이 필요하다. 멱등성 연산은 retry 를 해도 똑같은 결과가 나오는지를 말한다.**

- 바꾸는 방법은 쪼개면 되는데 예시로 보자.

```python
// (1) 먼저 pending Token 을 넣어둔다. 
oid = ObjectId()
try:
updateOne({ '_id': '2016-06-28'},
        {'$addToSet': {'pending': oid}},
        upsert=True)
except network err:
        try again, then throw

// (2) pending Token 이 있는 경우에만 연산을 실행하고 연산이 실행될 때 pending token 을 지운다. 
try:
  # Search for the document by _id and pending token.
  updateOne({'_id': '2016-06-28',
             'pending': oid},
            {'$pull': {'pending': oid},
             '$inc': {'counter': 1}},
            upsert=False)
except network err:
    try again, then throw

```

- `$pull` 은 지우는 연산을 말하고 `$addToSet` 은 한번만 실행되는 멱등성 연산자이다.

이번에는 내장 방식과 참조 방식을 비교해보자. 

내장 방식이 더 좋은 경우는 다음과 같다. 

- 작은 서브 도큐먼트인 경우. 
- 주기적으로 변하지 않는 데이터의 경우
- 결과적인 일관성이 허용될 때
- 증가량이 적은 데이터의 경우
- 자주 필요한 데이터의 경우, 두 번쨰 쿼리를 날리는데 필요한 경우 
- 빠른 읽기 

참조 방식이 더 좋은 경우는 다음과 같다. 

- 큰 서브 도큐먼트의 경우 
- 자주 변하는 데이터의 경우 
- 즉각적인 일관성이 필요한 경우
- 증가량이 많은 도큐먼트의 경우 
- 결과에서 자주 제외되는 데이터의 경우 
- 빠른 쓰기 

예로 Users 컬렉션이 있고, 계정 정보, 최근 활동 정보, 친구 정보가 있을 때 어떻게 저장할 지 생각해보자.

- 계정 정보는 사용자 도큐먼트와만 관련이 있으므로 내장 

- 최근 활동 정보 같은 경우는 증가량이 많다면 참조 방식으로 가야하지만 읽기 비용을 희생하고 싶지 않다면 서브셋 패턴을 적용해봐도 괜찮을 듯.

- 친구 정보는 즉각적인 일관성이 필요하고 증가량도 많을 수 있다. 그러므로 참조 관계로 가야한다.

## 관계의 카디널리티 

여기서 말하는 카디널리티는 인덱스에서 말한 카디널리티가 아니다.

관계의 카디널리티는 컬렉션이 다른 컬렉션을 얼마나 참조하고 있는 지를 나타내는 값이다.

- 일대일, 일대다, 다대다 이런 관계를 말하는 것. 

몽고 DB 에서는 관계를 말할 때 적은지 많은지 를 포함하면 좋다.

- 작성자가 게시물을 적게만 올리는 경향이 있다면 작성자과 게시물은 일대소 관계.
- 태그보다 게시물이 더 많다면 태그와 게시물은 소대다 관계이다. 
- 게시물마다 댓글이 달려있고 이게 많다면 게시물과 댓글은 일대다 관계이다. 

`다 (many)` 가 붙은건 참조라고 생각하면 되고 `소 (few)` 가 붙은건 내장이라고 생각하면 된다.

## 데이터베이스와 컬렉션 구상

- 모양이 유사하고 집계를 같이할 것 같은 도큐먼트들이 있다면 같은 컬렉션에 넣어두는게 좋다.
- 컬렉션에서는 락 (lock) 을 신경써야한다.
  - 일반적으로 쓰기 부하가 크다면 `--directoryperdb` 옵션을 통해서 데이터베이스마다 볼륨을 다르게 가져갈 수 있다. 
  - 이를 통해 여러 물리적 볼륨을 통해서 입출력 병목을 줄일 수 있다.
  - 예시로 사용자 데이터, 사용자 활동 데이터 (알람을 위한), 로그 데이터가 있다면 이것들을 다 다른 데이터베이스로 분리하는게 낫다.
  - 데이터베이스 > 컬렉션 > 도큐먼트 이 관계로 생각하면 된다.

## 일관성 관리

몽고 DB 는 다양한 수준의 일관성을 제공해줄 수 있다.

- 최신 데이터가 반영된 일관성, 비교적 정확한 일관성 (결과적 일관성) 등 

이런 일관성을 이해하려면 몽고 DB 는 서버와 어떻게 연결을 주고받는지 이해해야한다. 

- 서버는 몽고 DB 와의 연결을 맺고 이 연결에는 요청을 담는 큐가 있다.

- 새로운 요청을 보내면 큐의 가장 마지막에 들어간다. 즉 연결마다 일관성을 보장한다. 

- 단일 연결이라면 일관성의 문제가 업을 수도 있지만 연결을 여러개 열면 한 쪽 연결에서 삽입한 데이터를 다른 쪽 연결에서 조회했을 떄 없을 수도 있다. 이를 교차삽입 (interleaved insert) 라고도 부른다.

- 다행히 우리가 쓰는 드라이버는 여러개의 연결을 가지지만 결국에는 하나의 연결에 의해 처리되도록 보장한다. 이와 관련된 내용은 여기를 보자.
  - https://github.com/mongodb/specifications/blob/master/source/connection-monitoring-and-pooling/connection-monitoring-and-pooling.rst#connection

오히려 읽기를 Secondary 에서 읽어올 떄 일관성이 보장되지 않을 수 있다. 

- Secondary 는 Primary 보다 갱신이 느리기 떄문에.

- 이 경우에는 readConcern 을 이용하면 된다. 쓰기를 담당하는 writeConcern 과 같이 이용한다 일관성과 가용성을 보장하는게 가능하다.

- 수준은 local, available, majority, linearizable, snapshot 이렇게 다섯가지 단계가 있다.

- 일관성을 보장하려면 majority 를 쓰면 되고 linearizable 을 써도 된다.
  - majority 는 대부분의 복제셋 노드에서 확인된 데이터만 반환된다.
  - linearizable 은 모든 노드에서 확인된 데이터만 반환됨.

## 스키마 마이그레이션

애플리케이션이 커질수록 스키마도 변경될 여지가 많다.

그러므로 스키마를 신중하게 기록해야하고 이상적으로는 도큐먼트 버전 관리 패턴을 적용하는 것도 괜찮다.

스키마를 변경할 때 주의할 점은 특정한 문서에선 이 필드를 쓰는데 다른 문서에선 이거 대신 다른 필드를 쓴다거나 그런 경우다.

이 경우에는 코드가 복잡해질 여지가 있으므로 도큐먼트에 version 필드를 추가하는 것이 괜찮다. 이렇게하면 스키마를 엄격하게 관리할 수 있다.

**만약 스키마가 변경되었다고 이전에 있는 모든 문서를 바꾸도록 하는 건 권장하지 않는다. (몽고 DB 자체가 동적 스키마를 가지게 하는 이유가 없어짐.)**

- 이 작업을 하면 트랜잭션을 써야할 텐데 (모든 문서가 변경되었는지 확인을 해야하니까.) 상당한 부하가 들 듯.

## 스키마 관리

몽고 DB 3.2 이후부터는 갱신 및 삽입 중에 스키마 유효성 검사를 할 수 있다.

3.6 이후부터는 `$jsonSchema` 연산자를 통해서 JSON 스키마 유효성 검사를 할 수 있다.

## 몽고 DB 를 사용하지 않는 경우 

- 너무 많은 참조를 하는 경우 (조인이 많은 경우) 이 경우에는 관계형 DB 에 적합하다.

- **이전에 조인과 관련된 부분을 봤었을 때 두번의 쿼리까지는 괜찮은데 그 이후부터는 좀 성능이 떨어진다고 했었다.**
