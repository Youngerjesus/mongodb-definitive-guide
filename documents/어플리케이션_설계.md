# 어플리케이션 설계 

여기서는 어플리케이션에서 몽고 DB 를 효율적으로 작동하도록 설계하는 방법을 다룬다. 

- 스키마 설계 고려사항

- 데이터 내장 (embed) 방식과 참조 방식 중 결정하기 

- 최적화를 위한 팁 

- 일관성 고려 사항 

- 스키마 마이그레이션 방법 

- 스키마 관리 방법 

- 몽고 DB 가 데이터 스토로지로 적합하지 않은 경우 

## 스키마 설계 고려사항
 
스키마 설계를 관계형 데이터베이스와 똑같이 생각하면 안됨. 

- 관계형 데이터베이스는 주로 어플리케이션에 필요한 데이터를 생각해서 디자인 하는데 여기서는 그것외에 더 많은 고려가 필요하다.

스키마 설계할 때 고려할 사항은 다음과 같다.  

- 도큐먼트의 크기와 원자성 

  - 도큐먼트의 최대 크기는 16MB 이고 도큐먼트 단위로 갱신된다.
  - 원자성도 도큐먼트 단위이다.

- 쿼리 및 쓰기의 접근 패턴 

  - 어떻게 쿼리가 올 지 예측하고 쿼리 수를 최소화하고, 함께 쿼리되는 데이터가 동일한 도큐먼트에 저장되도록 설계해야한다. 
  - 도큐먼트를 쪼개지 말고 쿼리를 예측하고 쿼리를 도큐먼트에 포함시키라는 뜻 같다.

- 도큐먼트간 관계 유형

  - 도큐먼트 관계를 고려해야한다. 내부 도큐먼트로 넣을지, 어떻게 참조할 지를 고려해야한다. (추가 쿼리 없이 가능하면.) 
  - 갱신될 때 어떻게 갱신되는지도 고려해야함.
  - (참조는 조인을 말하는듯.)

- 카디널리티 

  - 도큐먼트의 관계가 정해졌다면 관계의 카디널리티도 고려해야한다. 
  - 관계의 카디널리티는 일대일인지, 일대다인지, 다대다인지, 일대수백만인지, 다대수십억인지 등을 고려하는 것. 
  - 몽고 DB 스키마에서 관계의 카디널리티를 설정하는 것이 중요하다. 
    - 수백만 개체가 개별적으로 접근되는지, 상위 개체의 컨택스트 내에서만 접근되는지, 읽기 갱신 비율은 어떻게 되는지를 고려하면 도큐먼트의 정규화 유무와 참조할지, 내장할지가 결정된다. 

## 스키마 설계 패턴 

적용할 수 있는 스키마 설계 패턴을 하나씩 보자.

### 다형성 패턴 (polymorphic pattern)

다형성 패턴은 컬렉션 내 모든 도큐먼트가 유사하지만 동일하지 않은 구조일 때 적합하다. 

이 패턴을 사용할 땐 공통 쿼리를 지원하는 공통 필드를 먼저 식별하는 것이 포함된다. 

그리고 도큐먼트나 서브 도큐먼트의 특정 필드를 추적해서 차이점을 알고 이를 통해서 어플리케이션에서 코딩하면 된다. 

### 속성 패턴 (attribute pattern)

속성 패턴은 정렬하거나 쿼리하려는 도큐먼트의 필드에 서브셋이 있는 경우나 필드가 도큐먼트의 서브셋에 존재하는 경우에 사용한다. 

이 경우에는 데이터를 키/값 쌍의 배열로 재구성하고 배열 요소에 인덱스를 만들면 된다.

### 버킷 패턴 (bucket pattern)

버킷 패턴은 데이터가 일정 기간 동안 스트림으로 유입되는 시계열 데이터에 적합하다. 

몽고 DB 에서 이런 데이터를 특정 시간 버위의 데이터를 보유하는 도큐먼트 셋으로 버킷화하면 훨씬 편리하다. 

예를 들어 1시간 버킷을 사용하면 해당 시간동안 모든 값을 하나의 도큐먼트 배열에 배치하는게 가능하다. 

그리고 도큐먼트 자체에는 이 버킷이 다루는 기간을 나타내는 시작과 종료 시간이 포함된다. 

### 이사치 패턴 (outlier pattern)

이상치 패턴은 도큐먼트의 쿼리가 어플리케이션의 정상적인 범위에 벗어난 경우를 표시하기 위해서 사용한다. 

예를 들면 인기도 (popularity) 가 중요한 상황을 위한 설계된 패턴으로 도서 판매, 주요 영향 요인등에 사용한다. 

플래그 (Flag) 를 통해서 도큐먼트가 이상치임을 나타낸다 

### 계산된 패턴 (computed pattern)

계산된 패턴은 데이터를 자주 계싼해야 할 때나 데이터 접근 패턴이 읽기 집약일 때 사용한다. 

계싼은 주기적으로 백그라운드에서 계산되도록 하고, 동일한 계산에 CPU 를 너무 많이 쓰지 않도록 주기를 두도록 한다. 


### 서브셋 패턴 (subset pattern)

서브셋 패턴은 장비의 램 용량을 초과하는 작업이 있을 때 사용한다. 

예를 들어서 어플리케이션에서 대용량의 데이터를 가지고 올 수 있는 경우에 발생하는 문제 떄문인데 매번 가지고 오는 경우가 아니라 드물게 가지고 오는 경우에 사용한다. 

서브셋 패턴은 자주 사용하는데 자주 사용하는 데이터와 자주 사용하지 않는 데이터를 두 개의 개별적인 컬렉션으로 분리해서 사용한다. 

- **(난 처음에 같은 컬렉션에 두고 인덱스로 구별하면 되지 않을까? 했는데 인덱스로 구별하는 것보다 풀스캔으로 가지고 오고 싶은 경우에 쓰지 않을까 싶다. 인덱스의 효율성이 그렇게 나오지 않는 경우라면 이렇게 쓰는 것인가.)**

일반적인 예로 전자 상거래 어플리케이션인데 최근 리뷰 몇 개와 모든 리뷰를 구별해서 컬렉션을 가져가는 경우에 쓸 수 있겠다. 


### 확장된 참조 패턴 (extended reference pattern)

확장된 참조 패턴은 하나의 컬렉션에 모든 정보를 다 넣어서 사이즈가 커지고, 성능이 느려지고, 데이터 중복이 생기는 문제를 피하고 이를 참조로 해결하자는 패턴이다. 

- 예를 들어 전자 상거래 어플리케이션에서 주문, 재고, 고객이 있다면 주문에 모든 데이터를 다 넣는게 아니라 주문과 고객 제고 를 분리하는 걸 말한다. 

### 근사 패턴 (approximation pattern)

근사 패턴은 리소스는 많이 들지만 (CPU, Memory, 시간 등) 결과는 비교적 정확하지 않아도 되는 경우에 사용할 수 있다. 

주로 이미지나 게시글의 추천 수가 이와 같은 상황인데 근사 패턴을 통해서 매번 갱신하는게 아니라 100회가 될 때마다 갱긴하도록 할 수 있다.

- **데이터베이스에 가능한 쓰기를 덜 하도록 하는게 핵심**


### 트리 패턴 (tree pattern)

트리 패턴은 구조적으로 계층적인 데이터가 있을 때 사용한다. 

일반적으로 함께 쿼리되는 데이터를 모아서 저장을 하고 몽고 DB 기준으로는 배열에 계층 구조를 넣어서 저장한다. 

예를 보면 전자 상거래의 제품 카탈로그를 보면 되는데 여러 범주에 속하거나 다른 제품의 하위 범주에 속하는 제품의 경우에 사용할 수 있다. 

하드 디스크의 경우 그 자체가 범주이지만 '기억장치' 범주에 속하고 '전자제품' 범주에 속한다. 

이 경우 즉각적임 범주 (= 하드 디스크) 와 전쳬 계층구조를 추적하는 필드가 있을 것이다. 

전체 계층구조를 추적하는 필드를 배열에 넣고 다중키 인덱스를 걸어놓는다.

### 사전 할당 패턴 (preallocation pattern)

사전 할당 패턴은 주로 MMAP 스토로지 엔진과 함께 사용했지만 여전히 사용되는 패턴이다. 

이 패턴은 빈 구조를 먼저 사전할당하고 이걸 이후에 채워넣는 방식이다. 

예를 들면 예약 정보를 관리하는 시스템에서 예약 가능 여부와 현재 예약 상태를 추적하는데 사용한다.


### 도큐먼트 버전 관리 패턴 (document versioning pattern) 

도큐먼트 버전 관리 패턴은 도큐먼트의 이전 버전을 유지하는 매커니즘을 제공한다. 

이 패턴을 쓰기 위해선 도큐먼트 버전을 추적하기 위해서 부가 필드가 필요하고 도큐먼트의 모든 수정 사항을 포함하는 추가 컬렉션이 필요하다. 

패턴을 쓸 땐 몇가지 고려사항이 있다.

- 각 도큐먼트의 수정 사항 너무 많으면 안되고

- 도큐먼트의 버전이 너무 많으면 또 안된다. 

- 대부분의 쿼리는 현재의 도큐먼트를 위주로 작성된다. 

