# 관리 

이 장에서는 다음의 내용을 다룬다. 

- 개별 멤버에 유지 보수 (maintenance) 수행하기 

- 다양한 환경에서 복제 셋 구성하기 

- 사용자 oplog 정보를 얻고 크기 조정하기 

- 좀 더 색다른 복제 셋 구성하기 

- 마스터/슬레이브 구조에서 복제 셋으로 전환하기 

## 유지 보수를 위해서 독립 실행형 모드에서 멤버를 시작

- **유지 보수 작업을 세컨더리에서 할 순 없다. 쓰기가 안되므로. 그렇다고 해서 프라이머리에서 한다면 성능에 영향읆 많이 끼친다.** 
  - **이 경우에 멤버를 독립 멤버 변수로 빼서 유지 보수를 한 후 다시 멤버로 연결 시키면 된다.** 
- 독립 실행형 모드로 시작할라면 인수를 봐야한다. 

```javascript
db.serverCmdLineOpts()
{
    "argv": ["mongod", "-f", "/var/lib/mongod.conf"], 
    "parsed": {
        "replSet": "mySet",
        "port": "27017",
        "dbpath": "/var/lib/db"
    }
}
```

- `replSet` 옵션 없이 시작을 한다면 독립 실행형으로 시작할 수 있다. 
- 다른 멤버와 통신하지 않기를 바란다면 `port` 번호도 바꿔야한다.
- `db.shutdownServer()` 로 서버를 종료시킨 후 `$ mongod --port 30000 --dbpath: /var/lib/db` 이런식으로 동작시키면 된다. 
- 유지 보수를 한 후 멤버를 다시 연결시키면 알아서 동기화가 된다. 

## 복제 셋 구성 

- 복제 셋 구성은 `local.system.replSet` 에 있고 모든 복제 셋이 같은 데이터 구조를 가진다. 
  - 여기에 있는 데이터를 `update` 를 통해서 변경하면 안된다. 차라리 `replSetReconfig` 를 하거나 `rs` 보조자를 하는게 맞다. 

### 복제 셋 생성하기 

- 멤버로 만들 `mongod` 를 시작하고 그 중 하나의 멤버에 `rs.initiate()` 를 통해서 구성 정보를 전달하면 복제 셋을 시작할 수 있다.
  - 주의할 건 복제 셋의 한 멤버에서만 `rs.initiate` 를 호출할 수 있다.

```javascript
var config = {
    "_id": <setName>,
    "members": [
        {"_id": 0, "host": <host1>},
        {"_id": 2, "host": <host2>},
        {"_id": 3, "host": <host3>},
    ]
}
            
rs.initiate(config)
```

### 복제 셋 멤버 교체하기 

- 복제 셋을 백업하거나 복구하는 작업은 23 장을 참고하자. 
- `rs.add()` 를 통해 멤버를 추가하거나 `rs.remove()` 를 통해 멤버를 제거할 수 있다. 
- 멤버의 설정을 바꿀 땐 제약사항이 있다. 
  - 멤버의 `_id` 는 바꿀 수 없다. 
  - 재구성 정보를 전달하는 멤버의 우선순위를 0으로 할 수 없다. 
  - 아비터에서 아비터가 아닌 것으로 변경할 수 없다. 
  - 멤버의 `buildIndexes` 를 false 에서 true 로 변경할 수 없다. 
- 멤버의 host 는 변경이 가능하다. 
- 바꿀 땐 `rs.config` 로 정보를 가져온 후 `rs.reconfig()` 로 새로운 수정 정보를 전달해서 복제 셋을 재구성할 수 있다. 

### 큰 복제 셋 만들기

- 복제 셋 멤버는 50 개, 투표하는 멤버는 7 개로 제한한다.
  - 이유는 다른 멤버와 통신하는 네트워크 트래픽량을 줄이고 선출에 걸리는 시간을 줄이기 위함이다. 

### 재구성 강제하기 

- 복제 셋의 과반수를 영구적으로 잃은 상황과 함께 프라이머리가 현재 없다면 세컨더리에서 재구성을 해야한다.
  - 일반적으로 재구성은 프라이머리에 요청을 한다. 근데 현재 프라이머리가 없고, 선출될 가능성도 없는 상황.
- 강제 재구성은 `rs.reconfig(config, {"force": true})` 를 통해서 이뤄진다. 
- 강제 재구성을 하는 경우 `version` 정보를 크게 높힌다. 버전 정보를 충돌하지 않도록 하기 위함이다.

## 멤버 상태 조작 

- 프라이머리에서 세컨더리로 변경하려면 `rs.stepDown()` 을 통해서 가능하다.
  - 프라이머리는 60초 동안 `SECONDARY` 상태가 된다. 그리고 그 기간동안 선출을 다시한다. 
  - 더 긴 기간동안 세컨더리로 만들려면 값을 명시하면 된다. `rs.stepDown(600)`
- `rs.freeze(10000)` 과 같은 명령을 통해서 프라이머리로 승격하지 못하게 막을 수도 있다. 

## 복제 모니터링 

- 복제 셋을 모니터링 하는 건 중요하다. 정상적으로 잘 작동하고 있는지 확인을 해야하니까. 
- 복제와 관련된 문제는 일시적일 떄가 많다. 네트워크 연결 때문에. 이는 로그를 확인하면 파악하기 쉽다. 
  - 그러므로 로그가 어디에 저장되는지 확ㅇ니하고, 로그가 잘 저장되면 해당 로그에 접근할 수 있음을 확실하게 하자.

### 상태 정보 가져오기 

- 복제 셋의 모든 멤버 정보를 가져올려면 `replSetGetStatus` 를 이용한 `rs.status()` 이다.
- 유용한 필드는 다음과 같다.
  - `self`: rs.status() 가 실행된 멤버에서만 존재하느 ㄴ것. 
  - `stateStr`: 서버의 상태를 나타내는 문자열 
  - `uptime`: 멤버에 도달할 수 있었던 시간을 말한다. 혹은 이 서버가 `self` 멤버를 위해 시작된 이후부터의 시간이다. 
  - `optimeDate`: 각 멤버의 `oplog` 에서 마지막 연산 수행 시간을 마한다. 
  - `lastHeartbeat`: 서버가 `self` 멤버로부터 마지막으로 하트비트를 받은 시간이다. 
  - `pingMs`: 이 서버에 대한 하트비트에 걸린 평균 시간을 말한다. 
  - `errMsg`: 멤버가 하트비트 요청에 반환하기로 한 모든 상태 메시지를 말한다. 정보 전달용이며 오류 메시지는 아니다.
  - `health`: 특정 서버가 도달 가능한지 (1) 도달 불가능한지 (0) 을 의미한다.

### 지연 계산하기 

- 복제를 추적하는 지표로 세컨더리가 프라이머리를 얼마나 잘 따라잡는지는 중요하다. 
  - `rs.status()` 를 통해서 멤버의 복제 상태를 볼 수 있다. 
  - 그리고 `rs.printReplicationInfo()` 나 `rs.printSlaveReplicationInfo()` 를 통해서 빠른 요약 정보를 얻는 것도 가능하다. 
  - `rs.printReplicationInfo()` 를 통해 `oplog` 의 사이즈와 `oplog` 의 사이즈가 몇 시간 용량인지도 나온다. 기본적으로 `oplog` 의 사이즈는 재동기화하는데 걸리는 시간만큼 길면 좋다. 
  - `rs.printSlaveReplicationInfo` 를 통해 각 멤버의 `syncedTo` 값과 마지막 `oplog` 항목이 각 세컨더리에 기록된 시간을 알 수 있다. 이 시간은 프라이머리를 기준으로 상대적으로 계산된다. 

### oplog 크기 변경하기 

- `oplog` 의 크기는 잘못된 세컨더리를 고칠 수 있는 데드라인 시간을 말한다. 
- 이 크기가 한 시간이라면 세컨더리를 유지 보수 할 수 있는 시간이 한 시간이라는 걸 말한다.
- **따라서 뭔가가 잘못될 때 약간의 숨 쉴 틈이 있다면 일반적으로 며칠에서 1주 정도 데이터를 보유할 수 있는 `oplog` 가 바람직하다.** 

### oplog 크기를 늘리려면 

```javascript
> use local 
> db.oplog.rs.stats(1024*1024).maxSize // 메가 바이트 단위로 출력됨 
> db.adminCommand({replSetResizeOplog: 1, size: 16000}) // 1만 6천 메가바이트로 설정 
```

### 인덱스 구축하기 

- 프라이머리는 정상적으로 인덱스를 구추갛며, 세컨더리는 `build index` 연산을 복제할 때 인덱스를 구축한다. 
- 인덱스 구축은 리소스 집약적인 연산이다. 이때는 멤버를 이용할 수 없을 수 있다. (이건 복제만 해당하며 샤드는 다르다.) 
  - `unique` 인덱스를 만들 땐 컬렉션에 대한 모든 쓰기를 잠시 종료해야한다. 
- 애플리케이션에서 영향을 최소화 하려면 인덱스는 한 번에 한 멤버씩 구축하는 것이 바람직하다. 
  - 세컨더리를 종료한 후 종료한다. 
  - 세컨더리를 독립 실행형 서버로 재시작한 후 인덱스를 구축한다. 
  - 인덱스 구축이 완료되면 서버를 복제 셋 멤버로 재시작한다. 재시작할 땐 `disableLogicalSessionCacheRefresh` 매개변수가 있으면 제거하자.
  - 이 과정을 모든 멤버에 반복한다. 
- 프라이머리에 인덱스를 구축하려면 프라이머리를 잠시 내리거나, 트래픽이 적을때 잠시 끄는 방법도 있다.
  - 고유 인덱스는 프라이머리에 먼저 구축해야한다. 아니면 중복 삽입이 될 수 있다.  
- 중요한 건 인덱스가 다르면 절대 프라이머리가 될 수 없다. 

## 한정된 예산에서 복제하기 

- 고성능 서버를 두 대 정도 사용할 수 없다면 값 싼 서버를 재해 복구용으로만 세컨더리로 쓰는 방법이 있다.
- 값 싼 서버 설정은 다음과 같다.
  - `primary`: 0 (해당 서버는 프라이머리가 될 수 없음.)
  - `hidden`: true (클라이언트는 해당 세컨더리에 요청을 보낼 수 없음)
  - `buildIndexes`: false (해당 서버가 처리해아 하는 부하를 상당히 줄일 수 있음)
  - `votes`: 0 (서버가 다운되더라도 프라이머리는 프라이머리로 유지되도록 한다. 서버가 두 대가 아니라 세 대라면 아비터로서 역할을 하도록 하면 됨.)
