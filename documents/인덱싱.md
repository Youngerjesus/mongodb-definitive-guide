# 인덱싱 

여기서는 몽고 DB 인덱스를 소개한다. 

인덱스를 쓰는 이유는 알겠지만 효율적으로 쿼리를 날리기 위함이다. 

여기서는 다음의 내용을 다룬다. 

- 인덱스의 정의와 사용하는 이유 

- 인덱싱할 필드를 선정하는 방법

- 인덱스 사용을 평가하고 적용하는 방법 

- 인덱스 생성 및제거에 대한 관리 정보 

***

## 인덱싱 소개 

`몽고 DB 가 쿼리에 효율적으로 응답하게 하려면 모든 쿼리 패턴에 인덱스를 등록하는게 중요하다.` 

몽고 DB 를 사용할 때 `explain` 함수를 이용하면 몽고 DB 가 뭘 하는지 알 수 있다. 

```javascript
db.query.find({
    query: '한국프로야구일정'
}).explain("executionStats")
```

````json
{"nReturned": new NumberInt("2"), "executionTimeMillis": new NumberInt("2"), "totalKeysExamined": new NumberInt("2"), "totalDocsExamined": new NumberInt("2"), "executionStages": {"stage": "SINGLE_SHARD", "nReturned": new NumberInt("2"), "executionTimeMillis": new NumberInt("2"), "totalKeysExamined": new NumberInt("2"), "totalDocsExamined": new NumberInt("2"), "totalChildMillis": new NumberLong("0"), "shards": [{"shardName": "iron01", "executionSuccess": true, "executionStages": {"stage": "FETCH", "nReturned": new NumberInt("2"), "executionTimeMillisEstimate": new NumberInt("0"), "works": new NumberInt("4"), "advanced": new NumberInt("2"), "needTime": new NumberInt("0"), "needYield": new NumberInt("0"), "saveState": new NumberInt("0"), "restoreState": new NumberInt("0"), "isEOF": new NumberInt("1"), "docsExamined": new NumberInt("2"), "alreadyHasObj": new NumberInt("0"), "inputStage": {"stage": "SHARDING_FILTER", "nReturned": new NumberInt("2"), "executionTimeMillisEstimate": new NumberInt("0"), "works": new NumberInt("3"), "advanced": new NumberInt("2"), "needTime": new NumberInt("0"), "needYield": new NumberInt("0"), "saveState": new NumberInt("0"), "restoreState": new NumberInt("0"), "isEOF": new NumberInt("1"), "chunkSkips": new NumberInt("0"), "inputStage": {"stage": "IXSCAN", "nReturned": new NumberInt("2"), "executionTimeMillisEstimate": new NumberInt("0"), "works": new NumberInt("3"), "advanced": new NumberInt("2"), "needTime": new NumberInt("0"), "needYield": new NumberInt("0"), "saveState": new NumberInt("0"), "restoreState": new NumberInt("0"), "isEOF": new NumberInt("1"), "keyPattern": {"query": new NumberInt("1"), "contentId": new NumberInt("1")}, "indexName": "ix_query_contentid", "isMultiKey": false, "multiKeyPaths": {"query": [], "contentId": []}, "isUnique": false, "isSparse": false, "isPartial": false, "indexVersion": new NumberInt("1"), "direction": "forward", "indexBounds": {"query": ["[\"한국프로야구일정\", \"한국프로야구일정\"]"], "contentId": ["[MinKey, MaxKey]"]}, "keysExamined": new NumberInt("2"), "seeks": new NumberInt("1"), "dupsTested": new NumberInt("0"), "dupsDropped": new NumberInt("0")}}}}]}}
````

- `explain("executionStats")` 모드를 통해서 인덱스를 이용한 쿼리를 분석할 수 있다.
- 중요한 칼럼으로는 `totalDocsExamined` 를 통해서 몽고 DB 쿼리를 실행하면서 살펴본 도큐먼트 개수를 알 수 있다.
- `executionStats` 에 있는 `millis` 필드를 통해서 쿼리를 실행하는데 걸린 시간을 알 수 있다.
- `nReturned` 필드를 통해서 반환받은 결과의 개수를 알 수 있다.

### 인덱스 생성 

여기서는 예시로 `username` 필드를 바탕으로 인덱스를 만들어본다. 

```javascript
db.users.createIndex({"username": 1})
```

- `createIndex` 를 통해서 인덱스를 만들어 볼 수 있다.  
- 컬렉션이 크지 않다면 인덱스를 만드는데 몇 초 정도 걸린다. 
- 인덱스 만드는데 진행상황을 알고 싶다면 `db.currentOp()` 를 실행해보자. 아니면 `mongod` 로그를 확인해서 인덱스 구축의 진행률을 체크해보자. 

당연한 소리지만 인덱스를 걸면 읽기는 빨라지지만 쓰기 작업은 느려진다. 

- **몽고 DB 의 인덱스는 관계형 DB 의 인덱스와 거의 동일하게 작동한다.**
