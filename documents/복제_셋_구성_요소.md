# 복제 셋 구성 요소 

여기서는 다음과 같은 내용을 다룬다. 

- 복제 셋 멤버가 새로운 데이터를 복제하는 방법 

- 새로운 멤버를 영입하는 방법 

- 선출이 작동하는 방법 

- 발생할 수 있는 서버 및 네트워크 오류 시나리오 


## 동기화

- 복제는 데이터의 여러 복사본을 가지기 위해서 한다.
- 복제는 몽고 DB 프라이머리가 수행한 쓰기를 모두 포함하는 로그인 *oplog* 를 보관함으로써 복제를 한다. 
  - 세컨더리 DB 는 이 oplog 를 쿼리함으로써 복제할 수 있다. 복제하고 나서 자신의 oplog 에 기록한다. 여기서 연산 적용에 실패하면 세컨더리는 종료된다.
    - 세컨더리가 재시작하면 oplog 에 있는 마지막 연산과 동기화된다. 
    - oplog 연산은 멱등성 있다. 
  - oplog 는 로컬 데이터베이스에 있는 제한 컬렉션이다.
  - **`local.oplog.rs` 컬렉션에서 볼 수 있는듯.**
  - oplog 는 크기가 고정되어 있어서 컬렉션에서 담을 수 있는 크기가 제한되어 있다.  
  - 크기는 쓰기 연산과 비슷하다. 프라이머리에 쓰기 연산이 분당 1킬로 바이트가 발생한다면, oplog 도 대략 분당 1킬로바이트씩 채워진다.
  - 삭제나 다중갱신처럼 여러 도큐먼트에 영향을 미치는 연산은 여러 개의 oplog 항목으로 분해된다. 
    - 예로 하나의 연나으로 100 만개의 도큐먼트가 삭제된다면 oplog 항목은 100만개가 생기고 하나씩 도큐먼트를 삭제된다. 
    - 그러므로 벌크 작업의 경우에는 oplog 가 빨리 찬다.
  - `oplogSizeMB` 옵션틀 통해서 크기를 지정할 수 있다.
    - 처음 복제 셋 멤버를 시작한 후에는 `Oplog 크기 변경 절차` 를 따라야한다. 

- 몽고 DB 의 데이터 동기화는 두 가지가 있다.
  - 전체 데이터셋으로 새 벰버를 동기화 하는 초기 동기화와 지속적으로 변경 사항을 복제하는 동기화 이렇게 두 가지가 있다.

### 초기 동기화 

- 초기 동기화는 한 멤버에서 다른 멤버로 모든 데이터를 복사한다.
  - 이떄 복사할 수 있는 **유효한 상태** 인지 확인한다.
  - 복제는 `local` 데이터베이스를 제외한 모든 데이터베이스를 말한다. 
  - 몽고 DB 3.4 이후부터 초기 동기화를 할 때 컬렉션 인덱스를 구축한다. (이전 단계에서는 `_id` 인덱스만 구축되었다.)
- 모든 데이터가 복사되면 `oplog` 를 사용해서 복제 셋의 현재 상태를 반영한다. 
- 초기 동기화를 통한 데이터 복사는 운영자 입장에서 작업하기가 쉽다. 데이터 디렉토리가 깔끔한 상태에서 `mongod` 를 시작하면 되니까.
  - 다만 백업으로부터 복원하는 방식이 더 바람직하다. 더 빠르기도 하고. 
    - 더 느리다면 `oplog` sync 가 안맞아져서 동기화가 느려지는 문제가 생길 수 있다. `oplog` 의 크기는 한정적이고 계속해서 덮어써지니까. 
  - 그리고 초기 동기화를 하면 메모리에 있는 자주 사용하는 데이터가 디스크로 향할 위험이 있으니까, 데이터 셋이 작은 경우에 적합하다.

### 복제 

- `oplog` 를 통해서 지속적으로 데이터를 복제하는 경우에는 비동기 (asynchronous) 프로세스에 적합하다. 
- 그리고 특정 노드가 다른 노드를 동기화 할 수 있는지 제어하는데는 규칙이 있다. 
  - 투표 수가 1 인 복제 셋 멤버는 투표 수가 0 인 멤버와 동기화하지 않는다. 
  - 세컨더리 멤버는 숨겨진 멤버나 지연된 멤버와 동기화하지 않는다.

### 실효처리 

- 세컨더리는 동기화가 많이 뒤떨어지면 실효 상태가 된다.
  - 실효의 뜻은 효력을 잃는다 라는 의미다.
  - **세컨더리가 다운 타임이거나, 쓰기 요청이 너무 많거나, 읽기 요청으로 인해 너무 많은 경우에 발생한다.**
- 세컨더리가 실효 상태가 되면 멤버로부터 `oplog` 를 조회해서 따라 잡을 수 있는지 확인한다.
  - 이게 가능하지 못하면 재가동을 하거나 최근의 데이터를 통해서 백업을 해야한다. 
  - 또 세컨더리가 충분히 따라잡을 수 있을만큼 큰 `oplog` 를 가지도록 설정도 해야한다.
  - **일반적인 oplog 는 2~3일 분량의 연산에 대한 크기를 적용할만큼의 사이즈를 가져야한다.**

## 하트비트 

- 멤버는 다른 멤버의 정보: (누가 프라이머리이고, 어떤 멤버가 지금 다운되었고, 누구로부터 동기화를 해야하고) 등을 확인할 수 있어야 한다. 
- 이걸 가능하게 하는게 **하트비트다. 기본적으로 2초 마다 보낸다.**

### 멤버 상태 

- 멤버들은 하트비트를 서로 주고 받는다. 
- 멤버들이 가질 수 있는 상태는 다음과 같다. 
  - `STARTUP`
    - 멤버를 처음 시작할 때의 상태다. 
    - 몽고 DB 가 멤버의 복제 셋 구성 정보를 로드할 때 되는 상태를 말한다.
  - `STARTUP2`
    - 초기 동기화 과정 전반에 걸쳐서 지속되는 시간이다. 단 몇 초 동안만 지속된다.
    - 이 단계 이후에는 `RECOVERING` 이 된따. 
  - `RECOVERING`
    - 멤버가 현재 올바르게 작동하지만 읽기 작업을 수행할 수 없음을 의미한다.
    - 시작 시 세컨더리가 되기 전에 짧게 이 상태가 되기도 한다. 
    - 동기화가 너무 뒤쳐질 때도 이 상태가 된다.
  - `ARBITER`
    - 아비터는 아비터만의 상태를 가진다.
  - `DOWN`
    - 멤버에게 도달할 수 없는 상태가 되면 이 상태가 된다.
    - 장애이거나 네트워크 이슈이거나.
  - `UNKNOWN`
    - 멤버가 다른 멤버에게 도달한 적이 없다면 상태를 모르므로 이 상태가 된다.
  - `REMOVED`
    - 멤버가 복제 셋으로부터 제거된 상태다.
  - `ROLLBACK`
    - 멤버가 데이터를 롤백할 때 사용된다.

## 롤백 

- 프라이머리에 생긴 쓰기 작업이 세컨더리에게 복제되기 전에 프라이머리가 종료되고 새로운 프라이머리가 생기고 이전 프라이머리가 복구되는 경우가 생기면 이전 프라이머리의 작업은 롤백된다.
- 몽고 DB 4.0 이전에서는 롤백 되는 데이터양의 제한이 있었는데 그 이후 부터는 없다. 
  - 4.0 이전에서는 데이터가 300 MB 를 초가하거나 롤백이 30분이상 걸린다면 가능하지 않았다.
  - 주로 세컨더리가 뒤쳐지고 프라이머리가 다운될 때 발생하는 일이다.
