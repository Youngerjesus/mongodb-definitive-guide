# 쿼리 

여기서 배울 내용은 다음과 같다. 

- 조건절을 이용한 범위 쿼리, 포함 관계, 부등 관계 등의 쿼리를 이용하는 방법 

- 쿼리는 필요할 때마다 도큐먼트 배치 (batch) 를 반환하는 데이터베이스 커서 (cursor) 를 반환한다는 내용 

- 커서 (cursor) 를 이용해 결과를 몇 개 건너뛰거나, 반환하는 결과 수를 제한하거나, 결과를 정렬하는 등 다영한 연산을 또 배운다.

## find 쿼리 

- `find` 함수를 통해 쿼리에 사용할 수 있다. 이 함수는 컬렉션 전체를 가져올 수도 있다. 
  - 첫 매개변수가 어떤 도큐먼트를 가지고 올 지 줘야한다. (이 매개변수가 조건절을 나타낸다.) 
  - 반환받는 도큐먼트에 있는 데이터가 모두 필요하지 않을 수 있다. 이 경우에는 필요만 데이터만 원하도록 설정할 수 있다. 이는 두 번째 매개변수로 주면 된다. 이때 `id` 값은 자동으로 준다.    
  - 반대로 받지 않을 데이터만 명시할 수도 있다. 이때는 값 쪽에 0 을 주면 된다. 1이 가지고 오라는 뜻이고 0이 가지고 오지 말란 뜻임.   
- 쿼리에는 제약 사항이 있는데 쿼리 에서 키와 값중에 값은 항상 상수여야 한다는 점이다. (물론 코드를 짜서 호출하는 경우에는 변수곘지만 여기서는 도큐먼트 내 다른 키의 값을 참조할 수 없단 뜻이다.)
  - 물론 `$where` 절과 같은 다른 쿼리 방법도 있다. 
- 쿼리 조건은 완전 일지 (exact match), 범위, OR 절, 부정 조건 (negation) 등 더 복잡한 조건으로 검색할 수 있다. 
  - `<, <=, >, >=` 에 해당하는 비교 연산자는 각각 `$lt, $lte, $gt, $gte` 이다. 
  - 키 값이 특정 값과 일치하지 않는 다는 조건을 쓰는거라면 `$ne` 를 써보자. (`$ne` 는 모든 데이터 형에 쓰는게 가능하다.)
- 몽고 에서는 `OR` 쿼리를 하는 방법이 두 가지가 있다. `$in` 을 이용한 방법과 `$or` 을 이용한 방법 
  - `$in` 은 하나의 키 값을 여러 값과 비교해보는 값이고, `$or` 은 여러 키 값을 비교하는 방식이다.
  - `$in` 과 반대로 `$nin` 은 매칭되지 않는 여러 값을 명시하는 방법이다. 
- `$not` 은 메타 조건절로 어떤 조건에서도 적용할 수 있다.
- `$mod` 는 키의 값을 첫 번쨰 값으로 나눈 후 나머지 값을 두 번째 값으로 넣는 연산자다. 

#### find 예제

모든 컬렉션을 가지고 오는 find 함수 
```javascript
db.c.find() 
```

#### find 예제 (2) 조건절 

조건절을 걸어서 필터를 걸 수 있다. 

조건을 같이 쓰면 `AND` 조건으로 표현된다. 
```javascript
db.users.find({ "age": 27, "username": "joe"})
```

#### find 예제 (3) 원하는 데이터 명시 

여기서는 username 과 age 만 가지고 오도록 명시했다. (값을 1 로 주면서, 0 으로 주면 가지고 오지 않음.) 
```javascript
db.users.find(
    {},
    { "username": 1, "age": 1}
)
```

#### 쿼리 조건절 예제 (1) 비교 

age 가 18 세 이상 30세 이하의 쿼리는 다음과 같다. 

```javascript
db.users.find(
    {"age": {"$gte": 18, "lte": 30}}
)
```

#### 쿼리 조건절 예제 (2) $ne

사용자 명이 `joe` 가 아닌 경우를 찾는 예제

```javascript
db.users.find(
    {"username": {"$ne": "joe"}}
)
```

#### 쿼리 조건절 예제 (3) $in

ticket 당첨 번호가 725, 542, 390 이라고 할 때 이에 해당하는 도큐먼트를 찾는 예제

```javascript
db.raffle.find(
    {"ticket_no": {"$in": [725, 542, 390]}}
)
```

#### 쿼리 조건절 예제 (4) $nin

ticket 당첨 번호가 725, 542, 390 이라고 할 때 당첨되지 않은 사람을 찾는 예제 

````javascript
db.raffle.find(
    {"ticket_no": {"$nin": [725, 542, 390]}}
)
````

#### 쿼리 조건절 예제 (5) $or 

ticket_no 가 725 거나 winner 가 true 인 경우를 찾는 예제

```javascript
db.raffle.find(
    {"$or": [{"ticket_no": 725}, {"winner": true}]}
)
```


#### 쿼리 조건절 예제 (6) $or 과 다른 연산자 

ticket_no 가 당첨 번호이거나 winner 가 true 인 경우를 찾는 예제

```javascript
db.raffle.find(
    {"$or": [{"ticket_no": {"$in": [742, 543, 390]}}, {"winner": true}]}
)
```

#### 쿼리 조건절 예제 (7) $mod

id 값을 `$mod` 를 통해 찾는 예제

id_num 값이 1, 6, 11, 16 등인 사용자를 반환한다. (5로 나눈 나머지 값과 1 을 비교하므로.)

```javascript
db.users.find(
    {"id_num": {"$mod": [5, 1]}}
)
```

#### 쿼리 조건절 예제 (8) $mod 와 $not

id_num 값이 1, 6, 11, 16 등이 아닌 사용자를 반환한다. 

````javascript
db.users.find(
    {"id_num": {"$not": {"mod": [5, 1]}}}
)
````

## 형 특정 쿼리 

몽고 DB 는 다양한 데이터 형을 가질 수 있는데 이런 형은 특정 쿼리에 반응할 수 있다. 이를 알아보자.

- `null` 은 스스로와 일치하는 것을 찾지만 존재하지 않음과도 일치한다.
  - 이는 키 값이 `null` 인 경우도 찾지만 키가 아예 없는 케이스도 찾는다.
  - 키 값만 `null` 인 경우를 찾으려면 `$exists` 조건절을 사용해야 한다. 
- `$regex` 는 패턴 일치 문자열을 찾는데 사용한다. 이때는 정규표현식에 사용되는 표현을 사용해야한다.  
- 배열에 쿼리하는 것도 가능하다. 배열의 요소 하나만 기준으로 쿼리할 때는 똑같다. 두 개 부터는 `$all` 을 사용해야한다. (`$all` 은 요소 순서 명시가 중요하지 않다.)
  - 물론 정확하게 일치하는 쿼리를 날리는 것도 가능하다. 이때는 순서도 중요해진다.
  - 특정 요소만을 쿼리할려면 `key.index` 를 이용해야한다. 
  - 특정 사이즈만을 검사하할려면 `$size` 를 이용해야한다. 현재 사이즈는 `$gt` 와 같은 조건절과 결합해서 사용할 수 없다. 
  - 이를 원한다면 `size` 필드를 따로 추가해서 사용하자. 그리고 이 값을 같이 갱신하도록 하면 된다. `$inc` 를 통해서
  - `$slice` 를 통해서 배열 내 부분집합을 받는것도 가능하다. 오프셋을 지정하는 것도 가능.  
- 내장 도큐먼트 쿼리는 도큐먼트 전체를 대상으로 하는 쿼리와 도큐먼트 내 키/값 을 대상으로 하는 지에 따라 다르다.
  - 전체를 대상으로 하면 정확하게 일치해야한다. 구조까지. 그러므로 이후에 구조가 변경되면 작동하지 않을 수 있다. 
  - 그러므로 특정 키/값으로 검색하는 방식이 낫다. (이 경우에는 `.`  을 붙여서 쿼리한다.)
  - 이런 이유로 도큐먼트 키에 `.` 을 붙일 수 없기도 하다. (URL 을 키로 못쓰는 이유. 이 경우에는 `.` 을 다른 문자로 변경해야 한다.)
- 키/값 쌍만으로는 다양한 쿼리를 할 수 있지만 안되는 경우도 있다. 이떄 `$where` 을 이용해서 복잡한 쿼리를 할 수 있다. 하지만 자바스크립트를 이용해야하고, 보안상의 문제가 있다 성능도 느리기도 하고 그러므로 자주 쓰지 말자.
  - `$where` 절 실행시에 각 도큐먼트는 BSON 에서 자바스크립트 객체로 변환되야한다. 그래서 느리다. 그리고 인덱스를 쓰는 것도 안된다. 
  - 즉 `$where` 을 쓴다면 인덱스나 쿼리 필터로 문서를 좀 거른 후에 세부 조정을 할 때 쓰자.
  - 몽고 3.6 부터는 `$expr` 이 나왔는데 이게 `$where` 보다 빠르므로 이걸 사용하자.

#### 형 특정 쿼리 예제 (1) exist 와 null

```javascript
db.c.find(
    {"z": {"$eq": null, "$exists": true}}
)
```

#### 형 특정 쿼리 예제 (2) $regex 대소문자 구별 x

Joe 나 joe 모두 찾고 싶은 경우

```javascript
db.users.find(
    {"name": {"$regex": "/joe/i"}}
)
```

joe 뿐 아니라 joey 도 찾고 싶다면

```javascript
db.users.find(
    {"name": {"$regex": "/joey?/i"}}
)
```

#### 형 특정 쿼리 예제 (3) 배열, 요소 하나로 찾는 경우 

fruit 에 apple, banana, peach 가 있는데 apple 을 찾는 경우 예제

```javascript
db.food.find(
    {"fruit": "apple"}
)
```

#### 형 특정 쿼리 예제 (4) 배열, 요소 두개로 찾는 경우 

```javascript
db.food.find(
    {"fruit": {"$all": ["apple", "banana"]}}
)
```

#### 형 특정 쿼리 예제 (5) 배열, 모두 일치

```javascript
db.food.find(
    {"fruit": ["apple", "banana", "peach"]}
)
```

#### 형 특정 쿼리 예제 (6) 배열 내 특정 요소 쿼리 (key.index)

두 번째 요소가 peach 인 경우를 찾는 예제 

````javascript
db.food.find(
    {"fruit.2": "peach"}
)
````

#### 형 특정 쿼리 예제 (7) size 를 이용한 쿼리 

````javascript
db.food.find(
    {"fruit": {"$size": 3}}
)
````

#### size 업데이트와 배열 내 요소를 넣는 쿼리 

````javascript
db.food.update(
    요소 찾을 조건절,
    {"$push": {"fruit": "strawberry"}, "$inc": {"size": 1}}
)
````

#### 형 특정 쿼리 예제 (8) $slice

게시물에서 먼저 달린 댓글 열 개 반환 (나중에 달린 댓글 10 개는 -10 을 하면 된다.)

```javascript
db.blog.posts.findOne(
    criteria,
    {"comments": {"$slice": 10}}
)
```

#### 내장 도큐먼트 쿼리하기 (1) 전체 도큐먼트 대상 

Joe Schmoe 라는 사람의 쿼리 

도큐먼트 구조는 이렇게 되어있음. 

````json
{
  "name": {
      "first": "Joe",
      "last": "Schmoe"
  },
  "age": 45
}
````

```javascript
db.people.find(
    {"name": {"first": "joe", "last": "Schemoe"}}
)
```

#### 내장 도큐먼트 쿼리하기 (2) 특정 키/값 으로 쿼리

```javascript
db.people.find(
    {"name.first": "Joe", "name.last": "Schmoe"}
)
```

#### $where 쿼리 사용법 


```javascript
db.foo.find(
    {"$where": function () {
        for (var currunt in this) {
            if (currunt != other && this[currunt] == this[other]) {
                return true 
            }
        } 
        return false 
    }}
)
```

## 커서 

- 데이터베이스는 커서를 사용해서 `find` 의 결과를 반환한다. 
  - 우리는 클라이언트 쪽 cursor 를 사용해 결과를 가져오고 데이터베이스 서버에서도 커서는 생긴다.
  - 서버측의 커서는 리소스 점유를 하고 있으므로 빨리 해지해주는게 좋다.
  - 서버 커서를 종료하는 조건은 다음과 같다. 
    - 종료 시키는 메소드를 호출한다.  
    - 클라이언트 측에서 유효형역을 벗어나는 경우에는 데이터베이스에서 메시지를 보내서 커서를 종료한다.
    - 커서의 모든 데이터를 다 읽는다. 
    - 10 분동안 활동이 없으면 종료된다.
  - 일반적으로는 타임아웃에 의한 종료를 한다.
  - 커서를 죽지 않도록 할려면 `immortal` 이라는 함수를 써야한다.
  - 남아있는 커서는 재시작 할 때까지 남아있다.
  - 죽지 않는 커서를 만들어서 계속해서 데이터를 받아오도록 할 수 있다. (tailable cursor 와 고정된 제한 컬렉션인 capped collection 이용해서.)
    - 주로 채팅이나 소켓, 로그와 같이 계속해서 데이터를 받아야 하는 경우에 사용한다.
- 주로 결과 개수를 제한하거나, 결과 몇 개를 건너뛰거나, 정렬하거나 등의 기능을 한다.
- 결과를 제한할 땐 `limit` 스킵할 땐 `skip` 을 이용하면 된다.
  - `skip` 은 찾고나서 폐기하는 것이므로 많은 수의 `skip` 을 하는 건 성능에 좋지 않다.
  - 
- 정렬할 땐 `sort` 를 이용하면 된다. 오름차순은 1 값을 내림차순은 -1 을 주면 된다.
  - 몽고는 하나의 키에 여러가지 형이 올 수 있다. 그러므로 데이터형에 따라서 정렬이 되는게 순서는 다음과 같다.
  - 최솟값 -> null -> 숫자 -> 문자열 -> 객체/도큐먼트 -> 배열 -> 이진데이터 -> 객체ID -> 불리언 -> 날짜 -> 타임스탬프 -> 정규표현식 -> 최댓값 

#### 커서 사용법 

```javascript
var cursor = db.collection.find() 

while (cursor.hasNext()) {
    next = cursor.next() 
}
```
