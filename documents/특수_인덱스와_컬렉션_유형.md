# 특수 인덱스와 컬렉션 유형 

여기서는 몽고 DB 가 사용할 수 있는 특수 인덱스와 컬렉션 유형을 다루겠다. 

- 큐와 같은 데이터를 위한 제한 컬렉션

- 캐시를 위한 TTL 인덱스 

- 단순 문자열 검색을 위한 전문 인덱스 

- 2D 구현 및 구면 기하학 (spherical geometry) 을 위한 공간 정보 인덱스 

- 대용량 파일 저장을 위한 GridFS 

## 공간 정보 인덱스 

몽고 DB 는 `2dsphere` 와 `2d` 공간 정보 인덱스를 가진다. 

`2dsphere` 를 이용하면 GeoJSON 형식으로 점, 선, 다각형의 기하 구조 (geometry) 를 지정할 수 있다. 

점은 경도와 위도 조표를 갖는 배열로 표현된다. 

## 왜 씀? 

공간을 이용한 정보에 쿼리를 날리기 위해서

- Map 과 같은 어플리케이션을 만든다면, 

#### 점의 표현 

```json
{
    "name": "New York City", 
    "loc": {
        "type": "Point",
        "coordinates": [50, 2]
    }
}
```

- 이와 비슷하게 선과 다각형도 표현할 수 있다. 

### 인덱스 만들기 

`createIndex` 와 `2dsphere` 를 통해서 공간 정보 인덱스를 만들 수 있다. 

```javascript
db.openStreetMap.createIndex({"loc": "2dsphere"})
```

### 공간 정보 쿼리 유형 

공간 정보 쿼리는 교차 (intersection), 포함 (within), 근접 (nearness) 라는 세 가지 유형이 있다. 

찾을 항목을 `{"$geometry: geoJsonDesc}` 와 같은 GeoJSON 객체를 통해서 찾는다.

먼저 교차부터 보자.

```javascript
var eastVillage = {
    "type": "Ploygon", // 다각형 뜻
    "coordinates": [
        [-73.5555, 40.5124091],
        [-72.5555, 41.5124091],
        [-71.5555, 42.5124091],
        [-70.5555, 43.5124091],
        ...
    ]
}

db.openStreetMap.find({"loc": {"$geoIntersects": {"$geometry": eastVillage}}})
```

- `$geoIntersects` 를 통해서 교차 쿼리를 날린다는 걸 알 수 있다. 

- 교차 쿼리는 `openStreetMap` 과 `eastVillage` 사이에서 한 점을 갖는 점과 선 그리고 다각형이 포함된 도큐먼트를 찾는다. 


다른 쿼리를 보자면 `$geoWithin` 을 통해서 포함 쿼리를 날릴 수 있다. 이는 (특정 지역에 완전히 포함된 항목의 쿼리를 찾을 때 사용한다.)

`$near` 과 같은 쿼리는 주변 위치에 쿼리를 날릴 수 있다. 이는 항상 거리가 가장 가까운 곳부터 가장 거리가 먼 곳 순으로 반환된다. 

## 전문 검색을 위한 인덱스 

몽고 DB 의 `text` 라는 인덱스는 전문 검색을 지원한다.

- `text` 인덱스는 몽고 DB 아틀라스 전문 검색 인덱스 (Atlas Full-Text Search Index) 와 혼동하지 말자. 이는 아파치 루씬을 이요아나. 

5장에서는 완전 일치와 정규 표현식을 이용해서 문자열에 쿼리를 했다.  

**다만 이 정규표현식 방식은 큰 텍스트 블록으로 검색을 한다면 쿼리 속도가 느리다.**

- 그리고 문법과 같은 언어 특성을 반영하는 것도 어렵다. `entry` 를 `entires` 와 일치하게 검색한다던지. 

**`text` 인덱스는 텍스트를 빠르게 검색하는 기능을 제공하고, 언어에 적합한 토큰화 (tokenization) 과 붕용어 (stopword), 형태소 분석등 일반적인 검색엔진 요구사항을 지원해준다.**

**`text` 인덱스에서 필요한 키의 개수는 인덱싱되는 필드의 단어 수에 비례한다. 필드에 단어 수가 많다면 많은 인덱스가 생성된다는 뜻.**

결과적으로 `text` 인덱스를 만들면 시스템 리소스를 많이 사용할 수 있다. 

**가능하면 인덱스 생성이 어플리케이션에 부정적인 영향이 가지 않도록 백그라운드에서 만들도록 해야하고, 우수한 성능을 보장하려면 생성되는 모든 `text` 인덱스가 램에 올라올 수 있는지 확인해야 한다.**

컬렉션에 쓰기 작업을 하면 인덱스도 써지는데 `text` 같은 경우는 문자열이 토큰화 되고, 형태소화 되면서 여러 인덱스에서 써진다.  

즉 쓰기 비용이 많다. 

**또한 샤딩을 하는 경우 데이터 이동 속도도 느려지며 모든 텍스트는 새 샤드로 마이그레이션 될 때 다시 인덱스 한다. (샤딩에서 데이터 이동을 하는구나)**

### 텍스트 인덱스 생성 

```javascript
db.articles.createIndex({
    "title": "text",
    "body": "text"},
    {"weights": {
        "title": 3, 
        "body": 2    
    }}
)
```

- `title` 과 `body` 가 텍스트 인덱스로 생성되었다. 

- 여기서 가중치도 넣을 수 있다. 여기서는 `title` 에 3 의 가중치를, `body` 에 2의 가중치를 넣었다.  

- 인덱스를 생성한 후에는 가중치를 따로 변경할 수 없다. 따라서 테스트를 해보고 적용해야한다. 

- 만약에 `text` 인덱스를 생성할 필드 이름을 모른다면 `$**` 를 통해서 모든 문자열 필드에 텍스트 인덱스를 생성할 수 있다. 

### 텍스트 검색 

`$text` 쿼리 연산자를 통해서 `text` 인덱스가 있는 컬렉션에 텍스트 검색을 수행할 수 있다. 

- 이때 공백과 대부분의 구두점 (punctuation) 을 구분 기호 (delimiter) 로 사용해서 문자열을 토큰화 한 후 모든 토큰에 대해서 기본적으로 `OR` 검색을 수행한다. 

다음 예제를 보자. 

```javascript
db.articles.find(
    {"$test": {"$search": "impact crater lunar"}},
    {title: 1},
).limit(10)
```

- 여기서는 `impact` OR `crater` OR `lunar` 검색을 수행할 것이다. 

- 결과 projection 은 title 만 가지고 오도록 했다. 

- 따로 관련성에 맞게 정렬되서 출력되지는 않는다.

기본적으로 `OR` 쿼리이기 때문에 관련성이 없을 수 있다. `AND` 쿼리로 변경하려면 `"\"impact crater\" lunar` 로 하면 `impact crater` OR `lunar` 로 검색하게 된다.

만약에 관련성에 맞게 정렬도 하고 싶다면 `$meta` 연산자를 통해서 메타데이터에 있는 `textScore` 를 이용하면 된다. 

쿼리 결과는 기본적으로 메타데이터와 연결되지만 따로 프로젝션닝 하지 않으면 출력되지 않는다.


#### 메타 데이터 이용한 정렬 

```javascript
db.articles.find(
    {"$test": {"$search": "\"impact crater\" lunar"}},
    {title: 1, score: {"$meta": "textScore"}},
).sort({"$meta": "textScore"}).limit(10)
```








