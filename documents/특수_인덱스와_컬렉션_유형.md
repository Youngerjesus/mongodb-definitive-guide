# 특수 인덱스와 컬렉션 유형 

여기서는 몽고 DB 가 사용할 수 있는 특수 인덱스와 컬렉션 유형을 다루겠다. 

- 큐와 같은 데이터를 위한 제한 컬렉션

- 캐시를 위한 TTL 인덱스 

- 단순 문자열 검색을 위한 전문 인덱스 

- 2D 구현 및 구면 기하학 (spherical geometry) 을 위한 공간 정보 인덱스 

- 대용량 파일 저장을 위한 GridFS 

## 공간 정보 인덱스 

몽고 DB 는 `2dsphere` 와 `2d` 공간 정보 인덱스를 가진다. 

`2dsphere` 를 이용하면 GeoJSON 형식으로 점, 선, 다각형의 기하 구조 (geometry) 를 지정할 수 있다. 

점은 경도와 위도 조표를 갖는 배열로 표현된다. 

## 왜 씀? 

공간을 이용한 정보에 쿼리를 날리기 위해서

- Map 과 같은 어플리케이션을 만든다면, 

#### 점의 표현 

```json
{
    "name": "New York City", 
    "loc": {
        "type": "Point",
        "coordinates": [50, 2]
    }
}
```

- 이와 비슷하게 선과 다각형도 표현할 수 있다. 

### 인덱스 만들기 

`createIndex` 와 `2dsphere` 를 통해서 공간 정보 인덱스를 만들 수 있다. 

```javascript
db.openStreetMap.createIndex({"loc": "2dsphere"})
```

### 공간 정보 쿼리 유형 

공간 정보 쿼리는 교차 (intersection), 포함 (within), 근접 (nearness) 라는 세 가지 유형이 있다. 

찾을 항목을 `{"$geometry: geoJsonDesc}` 와 같은 GeoJSON 객체를 통해서 찾는다.

먼저 교차부터 보자.

```javascript
var eastVillage = {
    "type": "Ploygon", // 다각형 뜻
    "coordinates": [
        [-73.5555, 40.5124091],
        [-72.5555, 41.5124091],
        [-71.5555, 42.5124091],
        [-70.5555, 43.5124091],
        ...
    ]
}

db.openStreetMap.find({"loc": {"$geoIntersects": {"$geometry": eastVillage}}})
```

- `$geoIntersects` 를 통해서 교차 쿼리를 날린다는 걸 알 수 있다. 

- 교차 쿼리는 `openStreetMap` 과 `eastVillage` 사이에서 한 점을 갖는 점과 선 그리고 다각형이 포함된 도큐먼트를 찾는다. 


다른 쿼리를 보자면 `$geoWithin` 을 통해서 포함 쿼리를 날릴 수 있다. 이는 (특정 지역에 완전히 포함된 항목의 쿼리를 찾을 때 사용한다.)

`$near` 과 같은 쿼리는 주변 위치에 쿼리를 날릴 수 있다. 이는 항상 거리가 가장 가까운 곳부터 가장 거리가 먼 곳 순으로 반환된다. 

## 전문 검색을 위한 인덱스 

몽고 DB 의 `text` 라는 인덱스는 전문 검색을 지원한다.

- `text` 인덱스는 몽고 DB 아틀라스 전문 검색 인덱스 (Atlas Full-Text Search Index) 와 혼동하지 말자. 이는 아파치 루씬을 이요아나. 

5장에서는 완전 일치와 정규 표현식을 이용해서 문자열에 쿼리를 했다.  

**다만 이 정규표현식 방식은 큰 텍스트 블록으로 검색을 한다면 쿼리 속도가 느리다.**

- 그리고 문법과 같은 언어 특성을 반영하는 것도 어렵다. `entry` 를 `entires` 와 일치하게 검색한다던지. 

**`text` 인덱스는 텍스트를 빠르게 검색하는 기능을 제공하고, 언어에 적합한 토큰화 (tokenization) 과 붕용어 (stopword), 형태소 분석등 일반적인 검색엔진 요구사항을 지원해준다.**

**`text` 인덱스에서 필요한 키의 개수는 인덱싱되는 필드의 단어 수에 비례한다. 필드에 단어 수가 많다면 많은 인덱스가 생성된다는 뜻.**

결과적으로 `text` 인덱스를 만들면 시스템 리소스를 많이 사용할 수 있다. 

**가능하면 인덱스 생성이 어플리케이션에 부정적인 영향이 가지 않도록 백그라운드에서 만들도록 해야하고, 우수한 성능을 보장하려면 생성되는 모든 `text` 인덱스가 램에 올라올 수 있는지 확인해야 한다.**

컬렉션에 쓰기 작업을 하면 인덱스도 써지는데 `text` 같은 경우는 문자열이 토큰화 되고, 형태소화 되면서 여러 인덱스에서 써진다.  

즉 쓰기 비용이 많다. 

**또한 샤딩을 하는 경우 데이터 이동 속도도 느려지며 모든 텍스트는 새 샤드로 마이그레이션 될 때 다시 인덱스 한다. (샤딩에서 데이터 이동을 하는구나)**

### 텍스트 인덱스 생성 

```javascript
db.articles.createIndex({
    "title": "text",
    "body": "text"},
    {"weights": {
        "title": 3, 
        "body": 2    
    }}
)
```

- `title` 과 `body` 가 텍스트 인덱스로 생성되었다. 

- 여기서 가중치도 넣을 수 있다. 여기서는 `title` 에 3 의 가중치를, `body` 에 2의 가중치를 넣었다.  

- 인덱스를 생성한 후에는 가중치를 따로 변경할 수 없다. 따라서 테스트를 해보고 적용해야한다. 

- 만약에 `text` 인덱스를 생성할 필드 이름을 모른다면 `$**` 를 통해서 모든 문자열 필드에 텍스트 인덱스를 생성할 수 있다. 

### 텍스트 검색 

`$text` 쿼리 연산자를 통해서 `text` 인덱스가 있는 컬렉션에 텍스트 검색을 수행할 수 있다. 

- 이때 공백과 대부분의 구두점 (punctuation) 을 구분 기호 (delimiter) 로 사용해서 문자열을 토큰화 한 후 모든 토큰에 대해서 기본적으로 `OR` 검색을 수행한다. 

다음 예제를 보자. 

```javascript
db.articles.find(
    {"$test": {"$search": "impact crater lunar"}},
    {title: 1},
).limit(10)
```

- 여기서는 `impact` OR `crater` OR `lunar` 검색을 수행할 것이다. 

- 결과 projection 은 title 만 가지고 오도록 했다. 

- 따로 관련성에 맞게 정렬되서 출력되지는 않는다.

기본적으로 `OR` 쿼리이기 때문에 관련성이 없을 수 있다. `AND` 쿼리로 변경하려면 `"\"impact crater\" lunar` 로 하면 `impact crater` OR `lunar` 로 검색하게 된다.

만약에 관련성에 맞게 정렬도 하고 싶다면 `$meta` 연산자를 통해서 메타데이터에 있는 `textScore` 를 이용하면 된다. 

쿼리 결과는 기본적으로 메타데이터와 연결되지만 따로 프로젝션닝 하지 않으면 출력되지 않는다.


#### 메타 데이터 이용한 정렬 

```javascript
db.articles.find(
    {"$test": {"$search": "\"impact crater\" lunar"}},
    {title: 1, score: {"$meta": "textScore"}},
).sort({"$meta": "textScore"}).limit(10)
```

### 전문 검색 최적화 

전문 검색을 최적화하는 방법은 두 가지이다. 

복합 인덱스를 통해서 검색의 범위를 좁히는 것. 

- **전문 검색 인덱스 앞에 다른 인덱스 필드를 둔다던지, 아님 그 역으로 둔다던지.**

### 다른 언어로 검색하기 

전문 검색 인덱스는 형태소를 분석할 떄 언어에 따라 형태소 분석 방법이 다르다. 

기본은 영어로 되어 있다. `text` 인덱스에서 언어를 지정할 때 `default_language` 옵션을 통해서 지정하는게 가능하다. 

예를 들어서 프랑스어 인덱스를 생성하려면 다음과 같다.

```javascript
db.users.createIndex(
    {"profil": "text"},
    {"default_language": "french"}
)
```

- 이제 별도로 언어를 지정하지 않는 한 프랑스어가 형태소 분석기로 사용한다. 

도큐먼트의 언어를 `language` 필드에 명시해서 언어를 지정하는 것도 가능하다.

```javascript
db.users.insert(
    {   
        "username": "swddishchef",
        "profile": "Bork de bfork", 
        language: "swedish"
    }
)
```

## 제한 컬렉션

몽고 DB 의 일반 컬렉션은 데이터가 계속해서 들어옮으로써 컬렉션의 크기는 계속해서 커진다. 

근데 몽고 DB 는 `제한 컬렉션` 이라는 것도 제공해주는데 이는 컬렉션의 크기를 고정시켜놓는걸 말한다.

제한 컬렉션에서 사용하는 자료구조는 원형 큐 (circular queue) 를 이용한다. 

- 빈 공간이 없으면 가장 오래된 도큐먼트가 지워지고 새로운 도큐먼트가 그 자리를 차지한다.

제한 컬렉션에서 허용되지 않는 작업들도 있다. 

- 일단 도큐먼트는 삭제되지 않는다. (가득차서 오래된 문서가 삭제되는 케이스 제외하고.)

- 도큐먼트의 크기가 커지도록 하는 갱신도 허용되지 않는다. 

제한 컬렉션은 디스크의 고정된 영역에 순서대로 기록된다. 

- 따라서 다소 쓰기를 빠르게 수행할 수 있다. 

제한 컬렉션은 유용성이 부족하지만 로깅에는 유용하다. 

제한 컬렉션은 그리고 샤딩될 수 없다. 

### 제한 컬렉션 생성 

```javascript
db.createCollection("my_collection", {"capped": true, "size": 100000, "max": 100})
```

- `createCollection` 을 통해서 생성할 수 있고 여기서는 10만 바이트 사이즈로 고정했다. 

- `max` 를 지정해서 도큐먼트의 수를 지정하는 것도 가능하다. 

- 제한 컬렉션은 일단 생성하면 수정은 불가능하니 조심하자.

- 기존의 일반 컬렉션을 제한 컬렉션으로 변환할 수도 있다. 

### tailable cursor

tailable cursor 는 결과를 모두 꺼낸 후에도 종료되지 않는 커서이다. (원래는 find 로 조회하면 커서가 나오는데 이는 결과를 다 보고나면 종료된다.) 

이 커서를 사용하는 이유는 데이터를 다 보고 난 이후에 데이터가 추가로 들어오면 또 읽기 위함이다. 

일반적으로 tailable cursor 는 제한 컬렉션에만 사용한다. **(스트림 변경 (change stream) 을 통해서 tailable cursor 보다 더 많은 제어와 구성을 가진 기능을 일반 컬렉션에서도 사용할 수 있다.)**

tailable cursor 도 10분동안 결과를 읽지 않으면 종료되므로 이 경우에는 다시 쿼리를 날리는 로직을 포함시켜야 한다. 


## TTL 인덱스 

TTL 인덱스를 이용해서 도큐먼트에 유효 시간을 설정하는 것이 가능하다. 

- 설정된 시간에 도달하면 도큐먼트는 지워진다. 

## GridFS 로 파일 저장하기 

GridFS 는 몽고 DB 에 대용량 이진 파일 (binary file) 을 저장하는 매커니즘이다., 

파일을 저장할 때 GridFS 를 쓰면 좋은 경우가 몇 가지 있다.

- 단순히 대용량의 파일을 저장하는 용도로. 

- 몽고 DB 의 복제나 자동 샤딩을 지원받고 싶다면. 

단점은 다음과 같다. 
- 대신에 파일 접근이 느리다. 

- 도큐먼트를 수정하는 경우에도 도큐먼트를 다시 지우고 업로드 해야한다.



