# 애플리케이션 복제 셋 연결

여기서는 어플리케이션이 복제 셋과 어떻게 상호작용하는지 살펴보자.

- 연결 및 장애 조치 수행 방법

- 쓰기 시 복제 대기하는 방법 

- 올바른 멤버에 읽기 요청을 라우팅 하는 방법 

## 클라이언트-복제 셋 연결 동작

- 몽고 DB 클라이언트 쪽 라이브러리 즉 드라이버는 몽고 DB 가 standalone 이든 replication 을 구성하든 똑같이 동작한다. 
  - 복제 셋을 구성하고 있다면 기본적으로 프라이머리와 연결되고 모든 트래픽은 프라이머리에게 향한다. 
- 드라이버에 연결할 때 시드 목록 (= 서버 목록) 을 제공하는 것도 가능하다. 
  - 시드는 애플리케이션이 데이터를 읽고 쓸 복제 셋의 멤버다.
  - 시드에는 모든 멤버를 나열할 필요는 없다.
  - `mongodb://server-1:27017,server-2:27017` 이런식으로 제공한다.
- 프라이머리가 없다면 기본적으로 드라이버는 읽기 및 쓰기 요청을 거부한다.
  - 근데 필요하다면 읽기 요청을 세컨더리에 사용할 수 있도록 드라이버를 구성하는 것도 가능하다.
- 이전 롤백에 대해서 배웠을 때 이전 프라이머리에 들어온 쓰기 요청이 세컨더리에 복제되기 전에 다운이 되면 해당 쓰기 요청은 새 프라이머리가 선출되면서 롤백될 수 있음을 말한다.
  - 단순한 블로그와 같은 어플리케이션이라면 이는 문제가 되지 않는데 쓰기 요청이 취소되면 안되는 유형의 어플리케이션도 있을 수 있다.
  - 이런 상황을 막으려면 **writeConcern 을 통한 과반수 이상의 세컨더리가 복제를 해야한 쓰기 응답을 받도록 하면 된다.** 
    - 이렇게 하면 새로운 프라이머리가 선출될 때 최신의 데이터를 반영하도록 할 수 있다.

### writeConcern Majority 적용 

자바스크립트 기준으로는 이렇게 하면 된다.

```javascript
try {
    db.products.insertOne(
        {"_id": 10, "item": "evelopes", "qty": "100", "type": "Self-Sealing"},
        {writeConcern: {"w": "majority", "timeout": 100}}
    )
} catch (e) {
    print(e)
}
```

- 이렇게 했을 경우 성공하면 `{"acknowledged": true, "insertedId": 10}` 이렇게 온다.

### "w" 에 대한 옵션 

- "majority" 가 유일한 writeConcern 의 옵션은 아니다. 
- 몽고 DB 는 다음처럼 W 에 숫자를 전달할 수 있다. 

```javascript
try {
    db.products.insertOne(
        {"_id": 10, "item": "evelopes", "qty": "100", "type": "Self-Sealing"},
        {writeConcern: {"w": "2", "timeout": 100}}
    )
} catch (e) {
    print(e)
}
```

- w 값에는 프라이머리를 포함한다는 점만 알아두자. 

## 사용자 정의 복제 보증

- 과반수 복제를 좀 더 엄격하게 하는 것도 가능하다.
  - 데이터센터마다 복제가 되도록
  - 숨겨지지 않은 노드에 복제가 되도록 
  - 이런 사용자 규칙을 만들어서 `getLastError` 에 넘겨주면 된다.


## 세컨더리로 읽기 전송 

- 기본적으로 드라이버는 모든 요청을 프라이머리에게 보낸다.
  - 프라이머리가 다운 타임이라면 읽기를 포함한 모든 요청은 취소된다.
  - 몽고에선 기본적으로 세컨더리에서 읽기를 권장하지 않는다. **(프라미어리가 다운되었을 때 읽는거 빼면은.)**
  - 일반적으로 부하를 분산하기 위해서 세컨더리를 읽자고 생각할 수 있는데 이 경우에는 **과부하**를 생각해야한다.
    - 세컨더리 하나가 장애가 났을 때 다른 복제 셋에게 가는 부하를 고려해야한다. 
    - 과부하로 인해 복제 자체가 늦처질수도 있고 새로운 멤버가 들어오는 경우도 쉽지 않을 수 있음.
    - 부하를 분산하려면 몽고에선 **샤딩** 을 고려해야한다.
- 읽기 요청을 항상 프라이머리에 보내는 건 읽기 선호도를 `primary` 라고 서정한 경우다.
- 읽기 요청을 항상 프라이머리지만 프라이머리가 다운 되었을 때 세컨더리가 처리하도록 할려면 `primaryPreferred` 로 지정하면 된다. 
- 세컨더리에서 읽을 때 가장 지연율이 낮은 곳에서 읽을려면 읽기 선호도를 `nearest` 로 지정하면 된다. 
  - 요청에 일관성보다 낮은 지연율이 필요하다면 `nearest` 를 쓰는게 낫다.
- 만약에 쓰기 작업을 모든 복제 셋에 쓰기가 되었을 경우까지 기다린다면 쓰기 속도가 희생되는데 이 경우에 항상 최신의 데이터를 읽지 않아도 된다면 읽기 선호도를 `secondary` or `secondaryPreferred` 로 지정하는 방법도 있다.

