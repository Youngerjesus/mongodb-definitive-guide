# 영속성 

영속성은 데이터베이스에 적용된 쓰기 작업이 영구적으로 유지되도록 하는 데이터베이스의 속성이다.

이 장에서 다루는 내용은 다음과 같다. 

- 몽고 DB 가 저널링을 통해 복제 셋 멤버 수준에서 영속성을 보장하는 방법 
- 몽고 DB 쓰기 결과 확인을 통해서 클러스터 수준에서 영속성을 확인하는 방법 
- 필요한 영속성 수준을 보장하도록 어플리케이션과 몽고 DB 클러스터를 구성하는 방법
- 몽고 DB 읽기 결과 확인을 통해서 클러스터 수준에서 영속성을 확인하는 방법 
- 복제 셋에서 트랜잭션의 영속성 수준을 설정하는 방법 

여기서는 운영 환경에서 기본적으로 제공해야하는 복제 셋 멤버는 3이라고 한다.

## 저널링을 통한 멤버 수준의 영속성 

- 서버 오류 발생시 영속성을 제공하기 위해서 몽고 DB 는 저널 (journal) 이란 곳에 로그를 먼저 기입해놓는다. (WAL: Write-Ahead-Log)
- WAL 은 영속성을 위해서 흔히 사용하는 기술이다.
- 대부분의 데이터베이스와 마찬가지로 몽고 DB 는 저널과 데이터베이스 데이터 파일을 인메모리 뷰에서 유지시켜놓는다.
- 저널 항목은 50 밀리초마다 디스크로 플러쉬가 되며 데이터베이스 데이터 파일은 60초 마다 디스크로 플러쉬된다.
  - 이 60초를 체크포인트 (checkpoint) 라고도 한다.
- **저널은 마지막 체크포인트 이후에 기록된 데이터의 영속성을 보장하기 위해서 사용된다.** 
  - 영속성 문제와 함께 시스템이 갑자기 종료되면 저널을 통해서 복구한다.
- 저널은 몽고 DB `dbpath` 디렉터리 아래에 `journal` 이라는 서브 디렉토리를 통해서 관리한다.
  - 와이어드타이거 (몽고 DB 스토로지엔진) 에서는 저널 파일에 `WiredTigerLog.<sequence>` 형식의 이름으로 저장된다.
- 몽고 DB 는 저널에 기록된 데이터를 압축하고 저널의 크기는 100MB 이다.
  - 저널 파일이 이 크기를 초과하면 새로운 저널 파일을 만들고 쓴다.
- 저널 파일은 마지막 체크 포인트 이후에 복구하는 작업에 쓰이므로 체크 포인트를 하개 되면 기존의 저널 파일은 제거된다.
- 충돌 또는 `kill -9` 가 발생하면 `mongod` 는 시작할 때 저널 파일을 다시 시작한다. 
  - 기본적으로 손실된 크기는 지난 100 밀리초 동안 작성된 쓰기와 저널 쓰기를 디스크에 플러시하는데 걸리는 시간을 합친 값이다.
  - 어플리케이션에 저널 플러시 간격이 더 짧아야 한다면 `mongod` 명령에 `--journalCommitInterval` 옵션을 통해서 지정하는게 가능하다. 여기서는 1~500 밀리초 안의 값을 설정할 수 있다.
- 또 다른 방법으로는 모든 쓰기 응답을 디스크 저널링이 될 경우에 받는 방법이 있다.

## 쓰기 결과를 확인하는 클러스터 수준의 영속성 

- 데이터 센터 중단이나 네트워크 파티션으로 인해서 복제 셋에 있는 일부 멤버에 쓰기가 복제되지 않을 수 있다.
- 복제 셋이 정상 상태로 돌아오면 대다수의 멤버에 복제되지 않은 쓰기는 이후에 롤백되기도 한다.
  - 어떤 어플리케이션의 경우에는 이런 롤백이 허용되기도 한다. 허용되지 않는 어플리케이션도 있고.
  - 몽고 DB 는 어플리케이션 개발자가 이를 지정할 수 있다.

### writeConcern 과 w 옵션

- 몽고 DB 는 삽입과 갱신 건에 대해서 쓰기 결과를 확인할 수 있다.
- `writeConcern` 에 `w: majority` 는 대부분의 복제 셋 멤버에 복제되었을 경우에만 쓰기 응답을 받도록 지정할 수 있다.
- 그리고 `wtimeout` 으로 지정해서 해당 작업의 타임아웃을 지정할 수 있다. 이는 일반적으로 지정해야한다.

### writeConcern 과 j 옵션 

- 쓰기 결과에서 `writeConcern` 에서  `j: true` 옵션을 줘서 온디스크에 저널이 기록되었을 때 응답을 받도록 지정할 수도 있다.
- **저널링을 쓰지 않는다면 서버의 갑작스런 종료가 생겼을 때 약 100밀리초 동안의 쓰기는 손실될 위험이 있다.**
- 그렇다고 무턱대고 저널링을 기록하면 성능이 많이 다운된다.

## 읽기 결과를 확인하는 클러스터 수준의 영속성 

- 몽고 DB 에서는 읽기 수준은 쓰기가 영속되기 전에도 읽을 수 있다.
- 읽기 수준과 쓰기 수준을 함께 사용해서 어플리케이션의 일관성과 가용성을 보장해줘야한다.
- 이때 읽기 선호도 (Read Preference) 와 데이터 읽는 위치를 혼동하지 말자. 
  - 읽기 선호도는 기본적으로 프라이머리에서만 읽는다.
- 읽기 격리 (readConcern) 은 기본적으로 local 이며 이는 다른 복제셋에 있다는 결과는 확인하지 않고 읽는다.
  - 즉 지금 읽은 데이터를 나중에 롤백되서 못 읽을 경우도 생긴다.
  - 격리가 `majority` 라면 대부분의 복제 셋이 가지고 있는 데이터만 전달해준다.
  - 격리가 `linearizable concern` 이라면 다수에 의해서 모두 승인된 쓰기만을 읽도록 보장해준다. (쓰기가 완료될 떄까지 기다린다.)

## 쓰기 결과를 확인하는 트랜잭션의 영속성 

- 몽고 DB 에서 개별 도큐먼트에 대한 작업은 원자적이다. 
- 여러 도큐먼트의 대한 작업에 원자성을 보장할려면 트랜잭션을 써야한다.
- 트랜잭션과 함께 쓰기 결과 확인을 같이 할 수도 있다.

## 몽고 DB 가 보장해주지 않는 것 

- 하드디스크나 파일 시스템에 문제가 생기면 당연히 해결해줄 수 없다.
  - 어떤 오래된 하드디스크는 쓰기가 실제로 성공하고 응답주는게 아니라 쓰기 처리 큐에 들어가기만해도 응답을 주기도 한다.

## 데이터 손상 확인 

- `validate` 명령을 통해서 컬렉션이 손상되었는지 확인할 수 있다.
- 이떄 확인할 사항은 `valid: true` 인지에 대한 것이다. 이게 아니면 손상에 대해서 말해준다.
- 인덱스 내 까지도 확인할려면 `db.movies.validate({full: true})` 와 같이 `full` 속성도 줘야한다.

